[![Typing SVG](https://readme-typing-svg.demolab.com?font=Fira+Code&weight=450&size=30&duration=5100&pause=800&width=437&lines=RESTful+API+%D0%B4%D0%BB%D1%8F+%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE+%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F+%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D1%87%D0%BD%D1%8B%D0%BC+%D0%BA%D0%B0%D1%82%D0%B0%D0%BB%D0%BE%D0%B3%D0%BE%D0%BC)](https://git.io/typing-svg)

Система должна позволять управлять информацией о книгах и читателях, а также процессом выдачи и возврата книг, с использованием JWT для аутентификации пользователей (библиотекарей).


## Глвная структура проекта
```text
librari-api/
├── database.py                             # Конфигурация БД
├── dependencies.py                         # Внедрение зависимостей
├── main.py                                 # Входная точка FastAPI
├── app/
│   ├── models/                             # Модели БД
│   │   ├── base_model.py                   # Базовая модель
│   │   ├── book_model.py                   # Модель книги
│   │   ├── borrowed_book_model.py          # Модель выданных книг
│   │   ├── librarian_model.py              # Модель библиотекаря
│   │   ├── person_model.py                 # Модель персональных данных
│   │   └── reader_model.py                 # Модель читателя
│   ├── repositories/                       # Слой работы с БД (Data Access Layer)
│   │   ├── base_repository.py              # Абстрактный репозиторий
│   │   ├── book_repository.py              # Репозиторий для работы с книгами
│   │   ├── borrowed_book_repository.py     # Репозиторий выданных книг
│   │   ├── librarian_repository.py         # Репозиторий библиотекарей
│   │   └── reader_repository.py            # Репозиторий читалелей
│   ├── routers/                            # API endpoints
│   │   ├── auth_router.py                  # Эндпоинты для аутентификации и авторизации
│   │   ├── book_router.py                  # Эндпоинты для книг 
│   │   ├── borrowed_book_router.py         # Эндпоинты для выдачи/возврата книг
│   │   ├── librarian_router.py             # Эндпоинты для библиотекарей
│   │   └── reader_router.py                # Эндпоинты для читателей
│   ├── schemas/                            # Pydantic схемы
│   │   ├── auth_schema.py                  # Схема для аутентификации и авторизации
│   │   ├── base_schema.py                  # Базовая схема
│   │   ├── book_schema.py                  # Схемы для книг
│   │   ├── borrowed_book_schema.py         # Схемы для выданных книг
│   │   ├── librarian_schema.py             # Схемы для библиотекарей
│   │   ├── person_schema.py                # Схемы для персональных данных
│   │   └── reader_schema.py                # Схемы для читателей
│   ├── services/                           # Бизнес-логика (сервисный слой)
│   │   ├── auth_service.py                 # Сервис для аутентификации и авторизации
│   │   ├── base_service.py                 # Базовый сервис
│   │   ├── book_service.py                 # Сервис для книг
│   │   ├── borrowed_book_service.py        # Сервис для выданных книг
│   │   ├── librarian_service.py            # Сервис для библиотекарей
│   │   └── reader_service.py               # Сервис для читателей
│   └── utils/                              # Вспомогательные утилиты
│       └── security.py                     # Модуль для работы с безопасностью и аутентификацией 
```

## Инструкция по запуску (Windows)
#### 1. Установить зависимости:
```python -m pip install -r requirements.txt```
#### 2. Создать в library-api файл .env и настроить в нем PostgreSQL:
```DATABASE_URL=postgresql://<user>:<password>@<host>:<port>/<dbname>```
#### 3. Применить миграции:
```alembic upgrade head```
#### 4. Запустить сервер:
```uvicorn app.main:app --reload```
#### 5. Открыть Swagger UI по ссылке:
```http://127.0.0.1:8000/docs```

## Структура БД и ее описание
![Image alt](https://raw.githubusercontent.com/L1KASA/library-api/refs/heads/master/diagram_db.jpg)

### Описание
#### Модель Base: Автоматически генерирует имена таблиц на основе названий классов, добавляет поля во все модели-наследники (id, created_at, updated_at)
#### Модель Person: Для хранения персональных данных библиотекарей и читателей, чтобы исключить дублирование данных (ФИО, email). При удалении данной модели автоматически удаляются связанные с ней Librarian/Reader.
#### Модель BorrowedBook: Для учета операций выдачи/возврата. Связывает Book, Reader и Librarian. Хранит дату выдачи и возврата.
#### Модель Librarian: Для хранения библиотекарей. Содержит ФИО, хеш пароля и почту. Удаляется при удалении связанной Person.
#### Модель Reader: Для хранения читателей. Содержит те же атрибуты, что и библиотекарь, но без пароля. Удаляется при удалении связанной Person.
#### Модель Book: Для хранения книг. При удалении данной модели каскадно удаляются записи в BorrowedBook. Имеет валидацию на неотрицательные значения.

### Описание реализации бизнес-логики
**Из сложного была обработка ошибки, которая возникала, когда предпринималась попытка удалить читателя, у которого либо была книга на руках, либо он в целом упоминался в выдаче. Реализованное решение:**
1. Многоуровневая проверка перед удалением (проверка активных задач)
2. Сначала удаляются все записи о выдача книг (каскадное удаление), а затем удаляется сам читатель и связанные персональные данные.

#### BookService
- Для работы использует только свой репозиторий.

- **Метод create()**:
1. Проверяет, есть ли уже книга с таким ISBN через `exists_by_isbn()`.
2. Проверяет, существует ли автор через `author_exists()`.
3. Если проверки пройдены - создает книгу через репозиторий.

- **Метод update()**:
1. Проверяет, существует ли книга.
2. Если обновляется ISBN - проверяет его уникальность среди других книг.
3. Выполняет обновление через репозиторий.

- **Метод delete()**:
1. Проверяет, существует ли книга.
2. Проверяет, нет ли активных выдач этой книги, чтобы информация о выдаче не пропала.
3. Если проверки пройдены - удаляет через репозиторий.

- **Метод get_by_id()**:
1. Пытается получить книгу через репозиторий. Бросает исключение, если не найдет
2. Возвращает найденную книгу по id.

- **Метод get_all()**:
1. Получает список всех книг без дополнительных бизнес-проверок.

#### BorrowedBookService
Для работы он использует три репозитория:
- `BookRepository` — управляет данными о книгах (проверяет доступность, обновляет количество экземпляров).
- `BorrowedBookRepository` — работает с записями о выданных книгах (создает новые записи, помечает возвраты, предоставляет историю).
- `ReaderRepository` — проверяет существование читателей в системе.

- **Метод borrow_book**:
1. Проверяет, существует ли читатель с указанным id (через вызов reader_exists в `ReaderRepository`).
2. Проверяет, есть ли в библиотеке экземпляры книги для выдачи (через is_book_available в `BookRepository`).
3. Проверяет, может ли читатель взять более 3 книг одновременно (get_active_borrowings из `BorrowedBookRepository`).
4. После успешного прохождения всех проверок сервис уменьшает количество доступных экземпляров книги через decrease_book_copies и создает новую запись о выдаче с помощью метода create в `BorrowedBookRepository`.

- **Метод return_book**:
1. Ищет запись о выдаче книги указанному читателю, которая еще не помечена как возвращенная. Дальнейшая работа прерывается, если книга уже возвращена или активной выдачи не найдено.
2. Обновляет данные (количество доступных экземпляров увеличивается на 1 через `increase_book_copies`, запись о выдаче, устанавливая дату возврата с помощью `mark_returned`).

#### LibrarianService
В отличие от предыдущих сервисов, он использует не только репозиторий (LibrarianRepository), но и дополнительный компонент PasswordSecurity для работы с паролями.

- **Метод create**:
1. Перед созданием записи проверяет уникальность email через метод `get_by_email()` репозитория. Если email уже занят, генерируется ошибка.
2. Пароль хешируется с помощью `PasswordSecurity`, после чего создается объект `LibrarianRepoCreate` с данными личности и хешированным паролем.
3. Финальное сохранение выполняется через метод `create()` репозитория.

- **Метод update**:
1. Проверяется существование библиотекаря через `get_by_id()`.
2. Если в обновляемых данных меняется email, выполняется дополнительная проверка его уникальности среди других записей.
3. Для обновления используется `LibrarianRepoUpdate` схема, которая содержит только те поля, которые можно изменять (на данный момент все, кроме пароля. Пароль меняесят отдельно).

- **Метод delete**:
Выполняет удаление библиотекаря после проверки его существования. В отличие от `BookService`, здесь нет дополнительных проверок на связанные сущности, так как в данной реализации предполагается, что удаление библиотекаря не влияет на историю выдач.

- **Методы get_by_id и get_by_email**:
Оба метода включают проверку существования записи и возвращают ValueError, если библиотекарь не найден. Метод `get_by_email()` дополнительно проверяет формат email на наличие символа @.

- **Метод get_all**:
Возвращает список всех библиотекарей в системе. Если список пуст, генерируется исключение, что может быть полезно для обработки пограничных случаев в клиентском коде.

#### ReaderServiceService
Сервис взаимодействует с ReaderRepository для выполнения операций с базой данных и обеспечивает соблюдение бизнес-правил при работе с читателями.
- Создание, обновление, получение по id/email как у Librarian, только без пароля.
  
- **Метод delete**:
1. Проверяет существование читателя.
2. Проверяет отсутствие не возвращенных книг (через репозиторий).
3. При наличии активных выдач возвращает понятное сообщение об ошибке.
4. Удаляет все связанные записи (выдачи, персональные данные).

#### AuthService
- AuthService является центральным сервисом для аутентификации и управления доступом в библиотечной системе. Он отвечает за три ключевые функции:
- Аутентификацию пользователей (библиотекарей)
- Генерацию и верификацию JWT-токенов
Сервис интегрируется с тремя основными компонентами:
`LibrarianRepository` - для доступа к данным библиотекарей
`PasswordSecurity` - для работы с хешированием паролей
`SecuritySettings` - для управления настройками безопасности

- **Метод **authenticate**:
1. Получает библиотекаря по email через репозиторий.
2. Проверяет соответствие пароля с использованием `PasswordSecurity`.
3. Возвращает объект Librarian при успешной аутентификации.
4. Генерирует понятные ошибки при неудачной попытке входа.
   
- **Метод **create_access_token**:
- Генерирует JWT-токен с указанными данными и сроком действия
  
- **Метод **verify_token**:
- Проверяет валидность токена и извлекает его содержимое
  
- **Метод **change_password**:
1. Проверяет текущий пароль.
2. Хеширует новый пароль.
3. Обновляет пароль через репозиторий.
4. Обеспечивает безопасность при передаче паролей через SecretStr

   
### Описание реализации аутентификации и авторизации
- JWT-токены генерируются с использованием библиотеки `python-jose`.
- Алгоритм подписи и секретный ключ задаются через `SecuritySettings` (загружаются из .env).
- Срок жизни токена регулируется параметром `access_token_expire_minutes`.
- При логине (/auth/login) система:
1. Проверяет email и пароль через `AuthService.authenticate()`
2. Создает токен с email в поле sub через `create_access_token()`
Верификация токенов происходит через `AuthService.verify_token()` с проверкой:
1. Корректности подписи
2. Наличия обязательного поля sub
3. Срока действия токена

### Использованные библиотеки: причина выбора
- Passlib (CryptContext): Хеширование паролей алгоритмом bcrypt, автоматическая проверка сложности пароля. Задает стандарт безопасности. 
- Python-JOSE (JWT): Активная поддержка, совместимость.
- Pydantic-Settings: Загрузка секретов из .env
- FastAPI Security: Готовые схемы аутентификации, интеграция зависимостей.

#### Защищенные эндпоинты:
1. Все POST, PUT, PATCH, DELETE операции. Но с одним но: библиотекаря могут изменять и удалять только свои данные.
2. Чувствительные операции: смена пароля и просмотр персональных данных.

### Особенности реализации:
1. Пароли хранятся как SecretStr для предотвращения случайного логирования
2. Все проверки выполняются на уровне сервисов, а не репозиториев
3. Каскадное удаление связей при удалении пользователей
4. Автоматический откат транзакций при ошибках

### Творческая часть
- Система рейтинга книг на основе их популярности:
1. Добавить в модель Book поле borrow_count для подсчета количества выдач, инкрементировать счетчик при каждой успешной выдаче.
2. Создать эндпоинт с количеством возвращаемых книг и фильтром по периоду (неделя/месяц и тд)
- Учесть, что авторов может быть несколько, и создать связь Many-to-Many между книгами и авторами. Для этого бы потребовалось:
1. Создать модель Author и промежуточную таблицу book_authors
2. Модифицировать все связанные эндпоинты
3. Добавить поиск по авторам
